#include "idte.h"
#include <stdint.h>

static const char IDTE_alphabet[IDTE_SIZE + 1] =
    "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";

/*
 * Reverse lookup table for Identitie encoding
 * Maps ASCII characters to their 6-bit values (0–63) based on:
 * "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$"
 *
 * Generated by:
 *  for (int i = 0; i < 128; ++i) table[i] = -1;
 *  for (int i = 0; i < 64; ++i) table[alphabet[i]] = i;
*/
static const int IDTE_reverseTable[128] = {
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, 63, -1, -1, -1,  // '$' = 63
    -1, -1, -1, -1, -1, -1, -1, -1,  0,  1,  // '0'–'9' = 0–9
     2,  3,  4,  5,  6,  7,  8,  9, -1, -1,
    -1, -1, -1, -1, -1, 36, 37, 38, 39, 40,  // 'A'–'Z' = 36–61
    41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
    51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
    61, -1, -1, -1, -1, 62, -1, 10, 11, 12,  // '_' = 62, 'a'–'z' = 10–35
    13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
    23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
    33, 34, 35, -1, -1, -1, -1, -1
};


u32 IDTE_encodeHash(u64 value, char out[12]) {
    for (u32 i = 10; i >= 0; --i) {
        out[i] = IDTE_alphabet[value & 0x3F];
        value >>= 6;
    }
    out[11] = '\0';
    return 12;
}

u8 IDTE_decodeHash(const char in[12], u64* out_value) {
    *out_value = 0;
    for (u32 i = 0; i < 11; ++i) {
        u32 c = (u32)in[i];
        if (c < 0 || c >= 128 || IDTE_reverseTable[c] == -1)
            return IDTE_INVALID;
        
        *out_value = (*out_value << 6) | IDTE_reverseTable[c];
    }
    return IDTE_SUCCESS;
}

u32 IDTE_encode(u64 value, char *out) {
    char buffer[12];
    u32 i = 0;
    
    if (value == 0) {
        buffer[i++] = IDTE_alphabet[0];

    } else {
        while (value > 0) {
            buffer[i++] = IDTE_alphabet[value % 64];
            value /= 64;
        }
    }

    for (u32 j = 0; j < i; ++j)
        out[j] = buffer[i - j - 1];
    
    out[i] = '\0';
    return i;
}

u8 IDTE_decode(const char* in, u32 length, u64 *out) {
    *out = 0;
    for (u32 i = 0; i < length; ++i) {
        u32 c = (u32)in[i];
        if (c < 0 || c >= 128 || IDTE_reverseTable[c] == -1)
            return IDTE_INVALID;
        
        *out = (*out * 64) + IDTE_reverseTable[c];
    }
    return IDTE_SUCCESS;
}
